

def images = [
    prepare: {
        echo "Preparing image build environment for ${env.IMAGE_NAME}:${env.IMAGE_TAG}"
    },
    build: {
        sh """
            docker build -t ${env.IMAGE_NAME}:${IMAGE_TAG}  .
            cd nginx
            docker build -t nouraldeen152/nginx_reverse_proxy:${IMAGE_TAG}  .
        """
    },
    push: {
        echo 'push images in my public regitry '
        withCredentials([usernamePassword(credentialsId: 'dockerhub', passwordVariable: 'PASS', usernameVariable: 'USER')]) {

            sh """

                docker push ${env.IMAGE_NAME}:${env.IMAGE_TAG}
                docker push nouraldeen152/nginx_reverse_proxy:${env.IMAGE_TAG}
            """
        }
    }
]

// ===== ENVIRONMENT MODULES ===== //

def k8s = [
    buildInfra: {
        echo "Building Kubernetes infrastructure"
        // Placeholder for Kubernetes infrastructure setup
    },
    prepare: {
        echo "Preparing Kubernetes environment"
        withCredentials([string(credentialsId: 'kubeconfig-secret', variable: 'KUBECONFIG_BASE64')]) {
        // Decode the kubeconfig and write it to a file
        sh """
            mkdir -p ${WORKSPACE}/.kube
            echo ${KUBECONFIG_BASE64} | base64 --decode > ${KUBECONFIG}
            chmod 600 ${KUBECONFIG}
        """
    }

    },
    deploy: {
        echo "Deploying to Kubernetes"
        dir('kubernates/') {
            sh """
                kubectl get nodes --kubeconfig=${KUBECONFIG}
                echo ${KUBECONFIG}
                export KUBECONFIG=${KUBECONFIG}
                chmod +x ./manage.sh 
                ./manage.sh apply
            """
        }

    }
]

def aws = [
    buildInfra: {
        echo "Building AWS infrastructure"
        dir('terraform/') {
            withCredentials([aws(accessKeyVariable: 'AWS_ACCESS_KEY_ID', 
                                 credentialsId: 'aws-credentials', 
                                 secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                sh """
                    terraform init -reconfigure
                    terraform apply -auto-approve 
                """ 

            }
        }
    },
    prepare: {
        echo "Preparing AWS environment"
        ansiblePlaybook(
            playbook: "ansible/site.yml",
            inventory: "ansible/hosts",
            limit: "${env.HOST_SUBSET_AWS}",
            // credentialsId: '', // Leave empty since we’re using a dynamic key
            extraVars: [
                selected_roles: 'docker_install',
                ansible_ssh_private_key_file: '.ssh/ssh_key.pem'
            ]
        )
    },
    deploy: {
        echo "Deploying to AWS"
        sh """
        cp docker-compose.yml ansible/roles/docker_compose/files/docker-compose.yml
        """
        // Runs Ansible to run docker-compose on target environments
        ansiblePlaybook(
            playbook: "ansible/site.yml",
            inventory: "ansible/hosts",
            limit: "${env.HOST_SUBSET_AWS}",
            // credentialsId: '', // Leave empty since we’re using a dynamic key
            extraVars: [
                selected_roles: 'docker_compose',
                IMAGE_TAG: "${IMAGE_TAG}",
                ansible_ssh_private_key_file: '.ssh/ssh_key.pem'
            ]
        )
    }
]

def onprem = [
    buildInfra: {
        echo "Building OnPrem infrastructure"
        // Placeholder for OnPrem infrastructure setup
    },
    prepare: {
        echo "Preparing OnPrem environment"
        // Runs Ansible to install packages (e.g., Docker) on target environments
        ansiblePlaybook(
            playbook: "ansible/site.yml",
            inventory: "ansible/hosts",
            limit: "${env.HOST_SUBSET_ONPREM}",
            credentialsId: 'jenkins-remote-credentials', 
            extraVars: [
                selected_roles: 'docker_install',
                ansible_os_family : 'RedHat'
            ]
        )
    },
    deploy: {
        echo "Deploying to OnPrem"
        sh """
        cp docker-compose.yml ansible/roles/docker_compose/files/docker-compose.yml
        """
        // Runs Ansible to run docker-compose on target environments
        ansiblePlaybook(
            playbook: "ansible/site.yml",
            inventory: "ansible/hosts",
            limit: "${env.HOST_SUBSET_ONPREM}",
            credentialsId: 'jenkins-remote-credentials', 
            extraVars: [
                selected_roles: 'docker_compose',
                IMAGE_TAG: "${IMAGE_TAG}"
            ]
        )
    
    }

]


pipeline {
    agent any
    // Define parameters
    parameters {

        choice(name: 'PIPELINE_ACTION', choices: ['build & deploy', 'build only', 'deploy only'], description: 'Choose pipeline action')
        string(name: 'CUSTOM_BUILD_NUMBER', defaultValue: "${BUILD_NUMBER}", description: 'Image tag (default: BUILD_NUMBER)')
        booleanParam(name: 'SKIP_TESTS', defaultValue: false, description: 'Skip running tests')
        // Checkbox-style environment selection
        booleanParam(name: 'DEPLOY_K8S', defaultValue: false, description: 'Deploy to Kubernetes')
        booleanParam(name: 'DEPLOY_AWS', defaultValue: false, description: 'Deploy to AWS')
        booleanParam(name: 'DEPLOY_ONPREM', defaultValue: false, description: 'Deploy to On-Prem support for remote machine')
        // Add more parameters as needed
   }    

    environment {
        HOST_SUBSET_ONPREM = 'on_prems'
        DOCKER_REGISTRY = 'your-docker-registry' // e.g., Docker Hub
        IMAGE_NAME = "nouraldeen152/networkapp"
        IMAGE_TAG =  "${params.CUSTOM_BUILD_NUMBER}" // Use custom build number or default to BUILD_NUMBER
        REMOTE_USER = 'jenkins-remote'
        REMOTE_HOST = '192.168.1.150'
        REMOTE_DIR = "/home/jenkins-remote/"
        KUBECONFIG = "${WORKSPACE}/.kube/config"
        SLACK_CHANNEL = '#team-project' // Slack channel to send notifications
    }
    stages {
        // Stage 1: Setup (hardcoded)
        stage('Setup Environment') {
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'aws_ec2_ssh_key', keyFileVariable: 'SSH_KEY',usernameVariable: 'USERNAME')]) {
                sh """
                   [ -d .ssh ] || mkdir -p .ssh
                    cat $SSH_KEY > .ssh/ssh_key.pem
                    chmod 400 .ssh/ssh_key.pem
                    echo "ssh_key_file=\\".ssh/ssh_key.pem\\"" >> terraform.tfvars
                """
                }
            }
        }

        // Stage 2: Parallel Build Phase
        stage('Build Phase') {
            when {
                expression { params.PIPELINE_ACTION in ['build only', 'build & deploy'] }
            }
            parallel {
                // Parallel Image Building
                stage('Build Images') {
                    steps {
                        script {
                            // build Docker images
                            images.build()
                        }
                    }
                }

                // Parallel Infrastructure Setup
                stage('Build Infrastructure') {
                    steps {
                        script {
                            if (params.DEPLOY_K8S) { k8s.buildInfra() }       // Not supported yet
                            if (params.DEPLOY_AWS) { aws.buildInfra() }
                            if (params.DEPLOY_ONPREM) { onprem.buildInfra() } // Not supported yet
                        }
                    }
                }
            }
        }
        // Stage 3: Push Images
        stage('Push Images') {
            when {
                expression { params.PIPELINE_ACTION in ['build only', 'build & deploy'] }
            }
            steps {
                script {
                    images.push()
                }
            }
        }
        // Stage 4: Testing
        stage('Testing') {
            when {
                allOf {
                    expression { !params.SKIP_TESTS }
                    expression { params.PIPELINE_ACTION in ['build & deploy', 'deploy only'] }
                }
            }
            steps {
                echo 'Running test suite...'
                // Add your test commands here
            }
        }
        // Stage 5: Parallel Deploy Phase
        stage('Deploy Phase') {
            when {
                expression { params.PIPELINE_ACTION in ['deploy only', 'build & deploy'] }
            }
            parallel {
                // Kubernetes Deployment
                stage('Deploy to K8s') {
                    when { expression { params.DEPLOY_K8S } }
                    steps {
                        script {
                            k8s.prepare()
                            k8s.deploy()
                        }
                    }
                }

                // AWS Deployment
                stage('Deploy to AWS') {
                    when { expression { params.DEPLOY_AWS } }
                    steps {
                        script {
                            aws.prepare()
                            aws.deploy()
                        }
                    }
                }

                // OnPrem Deployment
                stage('Deploy to OnPrem') {
                    when { expression { params.DEPLOY_ONPREM } }
                    steps {
                        script {
                            onprem.prepare()
                            onprem.deploy()
                        }
                    }
                }
            }
        }
    }
    post {
        always {
                        sh 'rm -rf .ssh'
                }
        success {

            slackSend(
                channel: env.SLACK_CHANNEL,
                message: "✅ Pipeline SUCCESSFUL: ${env.JOB_NAME} #${env.BUILD_NUMBER}\nBuild URL: ${env.BUILD_URL}"
            )
        }
        failure {
            slackSend(
                channel: env.SLACK_CHANNEL,
                message: "❌ Pipeline FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}\nBuild URL: ${env.BUILD_URL}"
            )
        }
        unstable {
            slackSend(
                channel: env.SLACK_CHANNEL,
                message: "⚠️ Pipeline UNSTABLE: ${env.JOB_NAME} #${env.BUILD_NUMBER}\nBuild URL: ${env.BUILD_URL}"
            )
        }
    }        
       
}
