# 0. Project Overview

## ğŸ“Œ Project Name
**Network Management System (NMS)**

## ğŸš€ Purpose
This application provides a centralized interface to manage and automate configurations across network devices. It enables DevOps-style operations for networking environments by integrating automation, orchestration, and infrastructure-as-code.

## ğŸ¯ Core Features

- **Inventory-Based Management**: Works with a dynamic inventory of routers and switches.
- **Device Overview**: 
  - Ping and display device status.
  - Individual pages for routers and switches.
- **Advanced Settings**:
  - Take device backups.
  - Apply saved configuration files.
  - Perform bulk configuration using string input.
- **Automation Actions**:
  - Configure OSPF, VLANs, banners, hostnames, and IPs.
  - Print current configuration data per device.
- **Access Control**:
  - Admin page to approve users and assign privileges.

> ğŸ§  While the appâ€™s UI is important, the primary focus is on the **DevOps integration** and automation pipeline.

---

## ğŸ› ï¸ Tech Stack & Tools

- **Django**: UI and REST interface.
- **Ansible**: Automation engine to control network devices.
- **Gunicorn**: WSGI HTTP server for production deployments.
  - *Benefits*: Better performance, concurrency handling, and separation of concerns compared to running Djangoâ€™s built-in server directly.
- **NGINX**: Acts as a reverse proxy to route traffic and serve static files.

---

## ğŸ“¦ Dockerization & Multi-Environment Setup

The application was containerized using **Docker** and pushed to a private Docker registry. Two images were created:
- Main application image (Django + Gunicorn)
- Optional custom NGINX image with pre-configured settings

### âœ… Supported Environments:
1. **Remote Server**: Runs the app as Docker containers
2. **AWS EC2**: Application deployed on Docker containers
3. **Kubernetes Cluster**: Full deployment using manifests and Helm

---

## ğŸ” CI/CD & Infrastructure Automation

A **Jenkins pipeline** was implemented to automate the entire lifecycle:

### ğŸ“‹ Pipeline Steps:
- Provision infrastructure using **Terraform** (AWS)
- (Planned) Create VMs using Terraform/Cloud-init
- Deploy Kubernetes setup via **Ansible** (planned)
- Build and push Docker images
- Deploy the app in different environments (parametrized)
- Send notifications to a **Slack team** with pipeline results

---

## ğŸ§  Key Takeaway

This project is a **DevOps-centric network automation system**, not just a web app. It demonstrates:
- Infrastructure as Code (IaC)
- Automation with Ansible
- Multi-environment deployment strategies
- CI/CD pipelines with real-world tools





# 0. Project Overview

## ğŸ“Œ Project Name
**Network Management System (NMS)**

## ğŸš€ Purpose
This application provides a centralized interface to manage and automate configurations across network devices. It enables DevOps-style operations for networking environments by integrating automation, orchestration, and infrastructure-as-code.

## ğŸ¯ Core Features

- **Inventory-Based Management**: Works with a dynamic inventory of routers and switches.
- **Device Overview**: 
  - Ping and display device status.
  - Individual pages for routers and switches.
- **Advanced Settings**:
  - Take device backups.
  - Apply saved configuration files.
  - Perform bulk configuration using string input.
- **Automation Actions**:
  - Configure OSPF, VLANs, banners, hostnames, and IPs.
  - Print current configuration data per device.
- **Access Control**:
  - Admin page to approve users and assign privileges.

> ğŸ§  While the appâ€™s UI is important, the primary focus is on the **DevOps integration** and automation pipeline.

---

## ğŸ› ï¸ Tech Stack & Tools

- **Django**: UI and REST interface.
- **Ansible**: Automation engine to control network devices.
- **Gunicorn**: WSGI HTTP server for production deployments.
  - *Benefits*: Better performance, concurrency handling, and separation of concerns compared to running Djangoâ€™s built-in server directly.
- **NGINX**: Acts as a reverse proxy to route traffic and serve static files.

---

## ğŸ“¦ Dockerization & Multi-Environment Setup

The application was containerized using **Docker** and pushed to a private Docker registry. Two images were created:
- Main application image (Django + Gunicorn)
- Optional custom NGINX image with pre-configured settings

### âœ… Supported Environments:
1. **Remote Server**: Runs the app as Docker containers
2. **AWS EC2**: Application deployed on Docker containers
3. **Kubernetes Cluster**: Full deployment using manifests and Helm

---

## ğŸ” CI/CD & Infrastructure Automation

A **Jenkins pipeline** was implemented to automate the entire lifecycle:

### ğŸ“‹ Pipeline Steps:
- Provision infrastructure using **Terraform** (AWS)
- (Planned) Create VMs using Terraform/Cloud-init
- Deploy Kubernetes setup via **Ansible** (planned)
- Build and push Docker images
- Deploy the app in different environments (parametrized)
- Send notifications to a **Slack team** with pipeline results

---

## ğŸ§  Key Takeaway

This project is a **DevOps-centric network automation system**, not just a web app. It demonstrates:
- Infrastructure as Code (IaC)
- Automation with Ansible
- Multi-environment deployment strategies
- CI/CD pipelines with real-world tools






